{"pages":[],"posts":[{"title":"1. 两数之和","text":"leetcode 本题链接 题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素 示例: 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 题解: 暴力解法 两层遍历 （虽然可以通过，但是速度很慢） 123456789var twoSum = function (nums: number[], target: number) { for (let i = 0, len = nums.length; i &lt; len - 1; i++) { for (let j = i + 1; j &lt; len; j++) { if (nums[i] + nums[j] === target) { return [i, j]; } } }}; 提交时间 提交结果 执行用时 内存消耗 语言 1年前 通过 148 ms N/A Javascript 用哈希表做记忆化由于每个值只能用一，在这里相当用哈希表存储 存储 值作为键，索引作为值（在各种记忆化的场景中都会用到） 123456789101112var twoSum = function (nums: number[], target: number) { let map: { [index: number]: number } = {}; nums.forEach((i: number, index) =&gt; { map[i] = index; }); for (let i = 0; i &lt; nums.length; i++) { let sec = target - nums[i]; if (!!map[sec] &amp;&amp; map[sec] !== i) { return [i, map[sec]]; // 这里ts 推断的 返回值的类型 是 number[]， 而不是 [number,number] ,而且这里可能不进这个if语句,ts又是如何判断的呢 } }}; 提交时间 提交结果 执行用时 内存消耗 语言 6 个月前 通过 92 ms 35.3 MB Javascript 仓库本题地址","link":"/2019/11/02/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"2. 两数相加","text":"leetcode 本题链接 题目描述给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例: 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 题解: 直接上代码 注意进位的问题 ,当两个链表长短不同时情况即可123456789101112131415161718192021var addTwoNumbers1 = function (l1: ListNode&lt;number&gt;, l2: ListNode&lt;number&gt;) { const firstNode = new ListNode((l1.val + l2.val) % 10); let currentNode = firstNode; let added = l1.val + l2.val &gt;= 10 ? 1 : 0; while (l1.next !== null || l2.next !== null) { l1 = l1.next ? l1.next : new ListNode(0); l2 = l2.next ? l2.next : new ListNode(0); let sum = l1.val + l2.val + added; added = sum &gt;= 10 ? 1 : 0; sum = sum % 10; currentNode.next = new ListNode(sum); currentNode = currentNode.next; } if (added &gt; 0) { currentNode.next = new ListNode(1); } return firstNode;}; 提交时间 提交结果 执行用时 内存消耗 语言 5 个月前 通过 200 ms 39 MB Javascript new ListNode(0) 这句是没有任何意义 直接去取值；并没有必要去新建一个复杂的数据类型 123456789101112131415161718192021222324252627var addTwoNumbers2 = function (l1: ListNode&lt;number&gt; | null, l2: ListNode&lt;number&gt; | null) { const firstNode = new ListNode((l1!.val + l2!.val) % 10); let currentNode = firstNode; let added = 0; l1 = l1 ? l1.next : null; l2 = l2 ? l2.next : null; while (l1 != null || l2 != null) { const v1 = l1 == null ? 0 : l1.val; const v2 = l2 == null ? 0 : l2.val; let sum = v1 + v2 + added; added = sum &gt;= 10 ? 1 : 0; sum = sum % 10; currentNode.next = new ListNode(sum); currentNode = currentNode.next; l1 = l1 ? l1.next : null; l2 = l2 ? l2.next : null; } if (added &gt; 0) { currentNode.next = new ListNode(1); } return firstNode;}; 提交时间 提交结果 执行用时 内存消耗 语言 5 个月前 通过 132 ms 39 MB Javascript 写成do while 12345678910111213141516171819202122232425var addTwoNumbers3 = function (l1, l2) { let firstNode; let currentNode = null; let added = 0; do { const v1 = l1 == null ? 0 : l1.val; const v2 = l2 == null ? 0 : l2.val; let sum = v1 + v2 + added; added = sum &gt;= 10 ? 1 : 0; sum = sum % 10; if (currentNode == null) { currentNode = firstNode = new LinkedList_1.ListNode(sum); } else { currentNode.next = new LinkedList_1.ListNode(sum); currentNode = currentNode.next; } l1 = l1 ? l1.next : null; l2 = l2 ? l2.next : null; } while (l1 != null || l2 != null); if (added &gt; 0) { currentNode.next = new LinkedList_1.ListNode(1); } return firstNode;}; 提交时间 提交结果 执行用时 内存消耗 语言 几秒前 通过 144 ms 39 MB Javascript 仓库本题地址","link":"/2019/11/04/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"title":"5. 最长回文子串","text":"leetcode 本题链接 题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例:示例 1： 输入: “babad”输出: “bab”注意: “aba” 也是一个有效答案。 示例 2： 输入: “cbbd”输出: “bb” 题解: 我的解法是 将可能的结果分成两种类型，逐个判断123456789101112131415161718192021222324252627282930313233var longestPalindrome = function (s: string) { const str = [...s]; let result: string[] = []; if (str.join(\"\") === str.reverse().join(\"\")) { return str.join(\"\"); } str.forEach((v, i, a) =&gt; { // 123321 格式 if (v === a[i + 1]) { let temp = 1; while ((i - temp &gt;= 0) &amp;&amp; (i + 1 + temp &lt;= a.length - 1) &amp;&amp; (a[i + 1 + temp] === a[i - temp])) { temp++; } temp--; if (result.length &lt;= 1 + 2 * temp) { result = a.slice(i - temp, i + 1 + temp + 1); } } // 123321 格式 if (a[i + 1] === a[i - 1]) { let temp = 1; while ((i - temp &gt;= 0) &amp;&amp; (i + temp &lt;= a.length - 1) &amp;&amp; (a[i + temp] === a[i - temp])) { temp++; } temp--; if (result.length &lt;= 1 + 2 * temp) { result = a.slice(i - temp, i + temp + 1); } } }); return result.join(\"\") || str[0];}; 速度还挺快的 提交时间 提交结果 执行用时 内存消耗 语言 13 天前 通过 80 ms 38.1 MB Javascript 仓库本题地址","link":"/2019/11/06/5.%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"title":"3. 无重复字符的最长子串","text":"leetcode 本题链接 题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例:示例 1: 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2: 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例 3: 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 题解: 在距离最相近的两个算相同的字符之间的距离，这些值中最小的值就是题目的解所以根本不需要管多余距离1的相同字符每次 值得注意的是 类似在0位置 就要得到 距离为1的，可以将初始值设置为 -11234567891011121314151617181920var lengthOfLongestSubstring = function (s: string) { const location: { [key: string]: number } = {}; let start_index = -1, max = 0; // start_index为当前子串的开始位置-1 for (let i = 0; i &lt; s.length; i++) { const character = s[i]; // 如果当前字符出现过，那么当前子串的起始位置为这个字符上一次出现的位置+1 if (location[character] &gt; start_index) { start_index = location[character]; } if (i - start_index &gt; max) { max = i - start_index; } location[character] = i; } return max;}; 提交时间 提交结果 执行用时 内存消耗 语言 5 个月前 通过 140 ms 40.2 MB Javascript 官方解1 滑动窗口 滑动窗口是数组/字符串问题中常用的抽象概念。窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 [i,j)（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将[i, j) 向右滑动 11 个元素，则它将变为 [i+1,j+1)（左闭，右开）。 回到我们的问题，我们使用 HashSet 将字符存储在当前窗口 [i, j)（最初 j = i）中。 然后我们向右侧滑动索引 jj，如果它不在 HashSet 中，我们会继续滑动 j。直到 s[j] 已经存在于 HashSet 中。此时，我们找到的没有重复字符的最长子字符串将会以索引 i 开头。如果我们对所有的 i 这样做，就可以得到答案。 12345678910111213141516var lengthOfLongestSubstring1 = function (s: string) { const n = s.length; const set = new Set(); let ans = 0, i = 0, j = 0; while (i &lt; n &amp;&amp; j &lt; n) { // try to extend the range [i, j] if (!set.has(s[j])){ set.add(s[j++]); ans = Math.max(ans, j - i); } else { set.delete(s[i++]); } } return ans;}; 复杂度分析 时间复杂度：O(2n) = O(n)，在最糟糕的情况下，每个字符将被 i 和 j访问两次。 空间复杂度：O(min(m, n))，与之前的方法相同。滑动窗口法需要O(k)的空间，其中 k 表示 Set 的大小。而 Set 的大小取决于字符串 n的大小以及字符集 / 字母 m 的大小。 提交时间 提交结果 执行用时 内存消耗 语言 5 个月前 通过 96 ms 38.3 MB Javascript 官方最优解 优化的 滑动窗口 上述的方法最多需要执行 2n 个步骤。事实上，它可以被进一步优化为仅需要 n个步骤。我们可以定义字符到索引的映射，而不是使用集合来判断一个字符是否存在。当我们找到重复的字符时，我们可以立即跳过该窗口。 也就是说，如果 s[j] 在 [i, j) 范围内有与 j’ 重复的字符，我们不需要逐渐增加 i 。 我们可以直接跳过 [i，j’] 范围内的所有元素，并将 i 变为 j’ + 1。 123456789101112var lengthOfLongestSubstring2 = function (s: string) { const n = s.length; let ans = 0; const map:{ [key: string]: number } = {}; // current index of character // try to extend the range [i, j] for (let j = 0, i = 0; j &lt; n; j++) { i = Math.max(map[s[j]] || 0, i); ans = Math.max(ans, j - i + 1); map[s[j]] = j + 1; } return ans;}; 提交时间 提交结果 执行用时 内存消耗 语言 5 个月前 通过 120 ms 40.2 MB Javascript 仓库本题地址","link":"/2019/11/05/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"}],"tags":[{"name":"哈希表","slug":"哈希表","link":"/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"滑动窗口","slug":"滑动窗口","link":"/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"}],"categories":[]}