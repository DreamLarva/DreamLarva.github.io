{"pages":[],"posts":[{"title":"1. 两数之和","text":"leetcode 本题链接 题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素 示例:给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] 暴力解法 两层遍历 （虽然可以通过，但是速度很慢） 123456789var twoSum = function (nums: number[], target: number) { for (let i = 0, len = nums.length; i &lt; len - 1; i++) { for (let j = i + 1; j &lt; len; j++) { if (nums[i] + nums[j] === target) { return [i, j]; } } }}; 提交时间 提交结果 执行用时 内存消耗 语言 1年前 通过 148 ms N/A Javascript 用哈希表做记忆化由于每个值只能用一，在这里相当用哈希表存储 存储 值作为键，索引作为值（在各种记忆化的场景中都会用到） 123456789101112var twoSum = function (nums: number[], target: number) { let map: { [index: number]: number } = {}; nums.forEach((i: number, index) =&gt; { map[i] = index; }); for (let i = 0; i &lt; nums.length; i++) { let sec = target - nums[i]; if (!!map[sec] &amp;&amp; map[sec] !== i) { return [i, map[sec]]; // 这里ts 推断的 返回值的类型 是 number[]， 而不是 [number,number] ,而且这里可能不进这个if语句,ts又是如何判断的呢 } }}; 提交时间 提交结果 执行用时 内存消耗 语言 6 个月前 通过 92 ms 35.3 MB Javascript 仓库本题地址","link":"/2019/11/02/1.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"title":"2. 两数相加","text":"leetcode 本题链接 题目描述给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例:输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) 输出：7 -&gt; 0 -&gt; 8 原因：342 + 465 = 807 直接上代码 注意进位的问题 ,当两个链表长短不同时情况即可123456789101112131415161718192021var addTwoNumbers1 = function (l1: ListNode&lt;number&gt;, l2: ListNode&lt;number&gt;) { const firstNode = new ListNode((l1.val + l2.val) % 10); let currentNode = firstNode; let added = l1.val + l2.val &gt;= 10 ? 1 : 0; while (l1.next !== null || l2.next !== null) { l1 = l1.next ? l1.next : new ListNode(0); l2 = l2.next ? l2.next : new ListNode(0); let sum = l1.val + l2.val + added; added = sum &gt;= 10 ? 1 : 0; sum = sum % 10; currentNode.next = new ListNode(sum); currentNode = currentNode.next; } if (added &gt; 0) { currentNode.next = new ListNode(1); } return firstNode;}; 提交时间 提交结果 执行用时 内存消耗 语言 5 个月前 通过 200 ms 39 MB Javascript new ListNode(0) 这句是没有任何意义 直接去取值；并没有必要去新建一个复杂的数据类型123456789101112131415161718192021222324252627var addTwoNumbers2 = function (l1: ListNode&lt;number&gt; | null, l2: ListNode&lt;number&gt; | null) { const firstNode = new ListNode((l1!.val + l2!.val) % 10); let currentNode = firstNode; let added = 0; l1 = l1 ? l1.next : null; l2 = l2 ? l2.next : null; while (l1 != null || l2 != null) { const v1 = l1 == null ? 0 : l1.val; const v2 = l2 == null ? 0 : l2.val; let sum = v1 + v2 + added; added = sum &gt;= 10 ? 1 : 0; sum = sum % 10; currentNode.next = new ListNode(sum); currentNode = currentNode.next; l1 = l1 ? l1.next : null; l2 = l2 ? l2.next : null; } if (added &gt; 0) { currentNode.next = new ListNode(1); } return firstNode;}; 提交时间 提交结果 执行用时 内存消耗 语言 5 个月前 通过 132 ms 39 MB Javascript 仓库本题地址","link":"/2019/11/04/2.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"}],"tags":[],"categories":[]}